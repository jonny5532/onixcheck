# 
# **************************************************
# *                                                *
# *               ONIX INTERNATIONAL               *
# *                                                *
# *     BOOK PRODUCT INFORMATION MESSAGE SCHEMA    *
# *                                                *
# *                  XHTML MODULE                  *
# *                RELAX NG VERSION                *
# *                                                *
# *          Original author: Francis Cave         *
# *          Recent revisions: Graham Bell         *
# *                                                *
# *                  Release 3.0                   *
# *                  Revision 2                    *
# *                Status: RELEASED                *
# *            Release date: 2009-04-09            *
# *              Revised: 2014-01-24               *
# *                                                *
# *             (c) 2000-2014 EDItEUR              *
# *             http://www.editeur.org/            *
# *                                                *
# **************************************************
# 
# 
# NOTE - THIS MODULE CORRESPONDS TO A SUBSET OF W3C XHTML 1.1. IT ONLY INCLUDES
# ELEMENTS AND ASSOCIATED ATTRIBUTES THAT ARE VALID INSIDE THE XHTML ELEMENT 
# 'body', AND EXCLUDES ELEMENTS FOR XHTML EMBEDDED OBJECTS, FORMS AND SCRIPTS AND 
# ATTRIBUTES THAT DEFINE BEHAVIOUR. SOME PARAMETER ENTITIES HAVE BEEN RENAMED 
# TO AVOID CLASHES WITH ONIX PARAMETER ENTITY NAMES.
# 
# 
# TERMS AND CONDITIONS OF USE OF THE ONIX BOOK PRODUCT INFORMATION MESSAGE SCHEMA
# 
# All ONIX standards and documentation are copyright materials, made available 
# free of charge for general use. If you use any version of the ONIX Book Product 
# Information Message Schema, you will be deemed to have accepted these terms and 
# conditions:
# 
# 1. You agree that you will not add to, delete from or amend any version of the 
# ONIX Product Information Message Schema, or any part of the Schema except for 
# strictly internal use in your own organisation.
# 
# 2. You agree that if you wish to add to, amend, or make extracts of any version 
# of the Schema for any purpose that is not strictly internal to your own organisation, 
# you will in the first instance notify EDItEUR and allow EDItEUR to review 
# and comment on your proposed use, in the interest of securing an orderly 
# development of the Schema for the benefit of other users.
# 
# A full licence agreement (DOI: 10.4400/nwgj) that governs use of EDItEURâ€™s ONIX
# documentation, DTDs and schemas is available on the EDItEUR website.
# 
# If you do not accept these terms, you must not use any version of the ONIX Product 
# Information Message Schema.
# 
# Full copies of all published versions of the latest release of this Schema and all 
# associated documentation are available from the EDItEUR web site, where may also be 
# found details of how to contact EDItEUR for advice on the use of this Schema. The URL 
# for the EDItEUR web site is:
# 
# http://www.editeur.org/
# 
# 
# SCHEMA REVISION HISTORY (IN REVERSE CHRONOLOGICAL ORDER)
# 
# 2014-01-24: removed <object> and <param> element definitions
# 
# 2012-01-27: added XHTML 1.1 <ruby> and associated <rb>, <rp>, <rt>, <rbc> and <rtc> tags
# 
# 2009-04-09: initial release
#

# ================ Character mnemonic entities =========================

# THE FOLLOWING ENTITY SETS ARE EXCLUDED FROM ALL VERSIONS OF THE ONIX SCHEMA. 
# 
# <!ENTITY % HTMLlat1 PUBLIC "-//W3C//ENTITIES Latin 1 for XHTML//EN" "xhtml-lat1.ent">
# %HTMLlat1;
# 
# <!ENTITY % HTMLsymbol PUBLIC "-//W3C//ENTITIES Symbols for XHTML//EN" "xhtml-symbol.ent">
# %HTMLsymbol;
# 
# <!ENTITY % HTMLspecial PUBLIC "-//W3C//ENTITIES Special for XHTML//EN" "xhtml-special.ent">
# %HTMLspecial;

# ================== Imported Names ====================================

namespace a = "http://relaxng.org/ns/compatibility/annotations/1.0"

XHTMLContentType = string
# media type, as per [RFC2045]

# comma-separated list of media types, as per [RFC2045]
Charset = string
# a character encoding, as per [RFC2045]

# a space separated list of character encodings, as per [RFC2045]
XHTMLLanguageCode = xsd:NMTOKEN
# a language code, as per [RFC1766]
Character = string
# a single character from [ISO10646]
XHTMLNumber = string
# one or more digits
LinkTypes = string
# space-separated list of link types

# single or comma-separated list of media descriptors
URI = string
# a Uniform Resource Identifier, see [RFC2396]
UriList = string
# a space separated list of Uniform Resource Identifiers

# date and time information. ISO date format
Script = string
# script expression
StyleSheet = string
# style sheet data
XHTMLText = string
# used for titles etc.

# render in this frame
Length = string
# nn for pixels or nn% for percentage length
MultiLength = string
# pixel, percentage, or relative

# comma-separated list of MultiLength
Pixels = string
# integer representing length in pixels

# these are used for image maps
Shape = "rect" | "circle" | "poly" | "default"
Coords = string
# comma separated list of lengths

# =================== Generic Attributes ===============================

# core attributes common to most elements
# id       document-wide unique id
# class    space separated list of classes
# style    associated style info
# title    advisory title/amplification
coreattrs =
  attribute id { xsd:ID }?,
  attribute class { text }?,
  attribute style { StyleSheet }?,
  attribute title { XHTMLText }?
# internationalization attributes
# lang        language code (backwards compatible)
# xml:lang    language code (as per XML 1.0 spec)
# dir         direction for weak/neutral text
i18n =
  attribute lang { XHTMLLanguageCode }?,
  attribute dir { "ltr" | "rtl" }?
attrs = coreattrs, i18n
# =================== Text Elements ====================================
special =
  br
  | span
  | bdo
  | # <ref name="object"/>
    img
  | map
fontstyle = tt | i | b | big | small
phrase =
  em
  | strong
  | dfn
  | code
  | q
  | sub
  | sup
  | samp
  | kbd
  | var
  | cite
  | abbr
  | acronym
gloss = ruby
inline = a | special | fontstyle | phrase | gloss
# %Inline; covers inline or "text-level" elements
Inline = (text | inline)*
# ================== Block level elements ==============================
heading = h1 | h2 | h3 | h4 | h5 | h6
lists = ul | ol | dl
blocktext = pre | hr | blockquote | address
block = p | heading | \div | lists | blocktext | table
Block = block*
# %Flow; mixes Block and Inline and is used for list items etc.
Flow = (text | block | inline)*
# ================== Content models for exclusions =====================

# a elements use %Inline; excluding a
a.content = (text | special | fontstyle | phrase | gloss)*
# pre uses %Inline excluding img, object, big, small, sup or sup
pre.content =
  (text | a | br | span | bdo | map | tt | i | b | phrase | gloss)*
# ruby allows %Inline elements excluding <ruby>
ruby.content = (text | a | special | fontstyle | phrase)*
# =================== Document Body ====================================
\div = element div { div.attlist, Flow }
# generic language/style container
div.attlist &= attrs
# =================== Paragraphs =======================================
p = element p { p.attlist, Inline }
p.attlist &= attrs
# =================== Headings =========================================

# There are six levels of headings from h1 (the most important)
# to h6 (the least important).
h1 = element h1 { h1.attlist, Inline }
h1.attlist &= attrs
h2 = element h2 { h2.attlist, Inline }
h2.attlist &= attrs
h3 = element h3 { h3.attlist, Inline }
h3.attlist &= attrs
h4 = element h4 { h4.attlist, Inline }
h4.attlist &= attrs
h5 = element h5 { h5.attlist, Inline }
h5.attlist &= attrs
h6 = element h6 { h6.attlist, Inline }
h6.attlist &= attrs
# =================== Lists ============================================

# Unordered list
ul = element ul { ul.attlist, li+ }
ul.attlist &= attrs
# Ordered (numbered) list
ol = element ol { ol.attlist, li+ }
ol.attlist &= attrs
# list item
li = element li { li.attlist, Flow }
li.attlist &= attrs
# definition lists - dt for term, dd for its definition
dl = element dl { dl.attlist, (dt | dd)+ }
dl.attlist &= attrs
dt = element dt { dt.attlist, Inline }
dt.attlist &= attrs
dd = element dd { dd.attlist, Flow }
dd.attlist &= attrs
# =================== Address ==========================================

# information on author
address = element address { address.attlist, Inline }
address.attlist &= attrs
# =================== Horizontal Rule ==================================
hr = element hr { hr.attlist, empty }
hr.attlist &= attrs
# =================== Preformatted Text ================================

# content is %Inline; excluding "img|object|big|small|sub|sup"
pre = element pre { pre.attlist, pre.content }
pre.attlist &=
  attrs,
  [ a:defaultValue = "preserve" ] attribute xml:space { "preserve" }?
# =================== Block-like Quotes ================================
blockquote = element blockquote { blockquote.attlist, Block }
blockquote.attlist &=
  attrs,
  attribute cite { URI }?
# ================== The Anchor Element ================================

# content is %Inline; except that anchors shouldn't be nested
a = element a { a.attlist, a.content }
a.attlist &=
  attrs,
  attribute charset { Charset }?,
  attribute type { XHTMLContentType }?,
  attribute name { xsd:NMTOKEN }?,
  attribute href { URI }?,
  attribute hreflang { XHTMLLanguageCode }?,
  attribute rel { LinkTypes }?,
  attribute rev { LinkTypes }?,
  attribute accesskey { Character }?,
  [ a:defaultValue = "rect" ] attribute shape { Shape }?,
  attribute coords { Coords }?,
  attribute tabindex { XHTMLNumber }?,
  attribute onfocus { Script }?,
  attribute onblur { Script }?
# ===================== Inline Elements ================================
span = element span { span.attlist, Inline }
# generic language/style container
span.attlist &= attrs
bdo = element bdo { bdo.attlist, Inline }
# I18N BiDi over-ride
bdo.attlist &=
  coreattrs,
  attribute lang { XHTMLLanguageCode }?,
  attribute xml:lang { XHTMLLanguageCode }?,
  attribute dir { "ltr" | "rtl" }
br = element br { br.attlist, empty }
# forced line break
br.attlist &= coreattrs
em = element em { em.attlist, Inline }
# emphasis
em.attlist &= attrs
strong = element strong { strong.attlist, Inline }
# strong emphasis
strong.attlist &= attrs
dfn = element dfn { dfn.attlist, Inline }
# definitional
dfn.attlist &= attrs
code = element code { code.attlist, Inline }
# program code
code.attlist &= attrs
samp = element samp { samp.attlist, Inline }
# sample
samp.attlist &= attrs
kbd = element kbd { kbd.attlist, Inline }
# something user would type
kbd.attlist &= attrs
var = element var { var.attlist, Inline }
# variable
var.attlist &= attrs
cite = element cite { cite.attlist, Inline }
# citation
cite.attlist &= attrs
abbr = element abbr { abbr.attlist, Inline }
# abbreviation
abbr.attlist &= attrs
acronym = element acronym { acronym.attlist, Inline }
# acronym
acronym.attlist &= attrs
q = element q { q.attlist, Inline }
# inlined quote
q.attlist &=
  attrs,
  attribute cite { URI }?
sub = element sub { sub.attlist, Inline }
# subscript
sub.attlist &= attrs
sup = element sup { sup.attlist, Inline }
# superscript
sup.attlist &= attrs
tt = element tt { tt.attlist, Inline }
# fixed pitch font
tt.attlist &= attrs
i = element i { i.attlist, Inline }
# italic font
i.attlist &= attrs
b = element b { b.attlist, Inline }
# bold font
b.attlist &= attrs
big = element big { big.attlist, Inline }
# bigger font
big.attlist &= attrs
small = element small { small.attlist, Inline }
# smaller font
small.attlist &= attrs
# ==================== Object ======================================

# object is used to embed objects as part of HTML pages.
# param elements should precede other content. Parameters
# can also be expressed as attribute/value pairs on the
# object element itself when brevity is desired.

# <define name="object">
#	<element name="object">
#		<ref name="object.attlist"/>
#		<zeroOrMore>
#			<choice>
#				<text/>
#				<ref name="param"/>
#				<ref name="block"/>
#				<ref name="inline"/>
#			</choice>
#		</zeroOrMore>
#	</element>
# </define>
# <define name="object.attlist" combine="interleave">
#	<ref name="attrs"/>
#	<optional>
#		<attribute name="declare">
#			<choice>
#				<value>declare</value>
#			</choice>
#		</attribute>
#	</optional>
#	<optional>
#		<attribute name="classid">
#			<ref name="URI"/>
#		</attribute>
#	</optional>
#	<optional>
#		<attribute name="codebase">
#			<ref name="URI"/>
#		</attribute>
#	</optional>
#	<optional>
#		<attribute name="data">
#			<ref name="URI"/>
#		</attribute>
#	</optional>
#	<optional>
#		<attribute name="type">
#			<ref name="XHTMLContentType"/>
#		</attribute>
#	</optional>
#	<optional>
#		<attribute name="codetype">
#			<ref name="XHTMLContentType"/>
#		</attribute>
#	</optional>
#	<optional>
#		<attribute name="archive">
#			<ref name="UriList"/>
#		</attribute>
#	</optional>
#	<optional>
#		<attribute name="standby">
#			<ref name="XHTMLText"/>
#		</attribute>
#	</optional>
#	<optional>
#		<attribute name="height">
#			<ref name="Length"/>
#		</attribute>
#	</optional>
#	<optional>
#		<attribute name="width">
#			<ref name="Length"/>
#		</attribute>
#	</optional>
#	<optional>
#		<attribute name="usemap">
#			<ref name="URI"/>
#		</attribute>
#	</optional>
#	<optional>
#		<attribute name="name">
#			<data type="NMTOKEN"/>
#		</attribute>
#	</optional>
#	<optional>
#		<attribute name="tabindex">
#			<ref name="XHTMLNumber"/>
#		</attribute>
#	</optional>
# </define>

# param is used to supply a named property value.
# In XML it would seem natural to follow RDF and support an
# abbreviated syntax where the param elements are replaced
# by attribute value pairs on the object start tag.

# ><define name="param">
#	<element name="param">
#		<ref name="param.attlist"/>
#		<empty/>
#	</element>
# </define>
# <define name="param.attlist" combine="interleave">
#	<optional>
#		<attribute name="id">
#			<data type="ID"/>
#		</attribute>
#	</optional>
#	<optional>
#		<attribute name="name"/>
#	</optional>
#	<optional>
#		<attribute name="value"/>
#	</optional>
#	<optional>
#		<attribute name="valuetype" a:defaultValue="data">
#			<choice>
#				<value>data</value>
#				<value>ref</value>
#				<value>object</value>
#			</choice>
#		</attribute>
#	</optional>
#	<optional>
#		<attribute name="type">
#			<ref name="XHTMLContentType"/>
#		</attribute>
#	</optional>
# </define>

# =================== Images ===========================================

# To avoid accessibility problems for people who aren't
# able to see the image, you should provide a text
# description using the alt and longdesc attributes.
# In addition, avoid the use of server-side image maps.
# Note that in this DTD there is no name attribute. That
# is only available in the transitional and frameset DTD.
img = element img { img.attlist, empty }
img.attlist &=
  attrs,
  attribute src { URI },
  attribute alt { XHTMLText },
  attribute longdesc { URI }?,
  attribute height { Length }?,
  attribute width { Length }?,
  attribute usemap { URI }?,
  attribute ismap { "ismap" }?
# usemap points to a map element which may be in this document
# or an external document, although the latter is not widely supported

# ================== Client-side image maps ============================

# These can be placed in the same document or grouped in a
# separate document although this isn't yet widely supported
map = element map { map.attlist, (block+ | area+) }
map.attlist &=
  i18n,
  attribute id { xsd:ID },
  attribute class { text }?,
  attribute style { StyleSheet }?,
  attribute title { XHTMLText }?,
  attribute name { xsd:NMTOKEN }?
area = element area { area.attlist, empty }
area.attlist &=
  attrs,
  [ a:defaultValue = "rect" ] attribute shape { Shape }?,
  attribute coords { Coords }?,
  attribute href { URI }?,
  attribute nohref { "nohref" }?,
  attribute alt { XHTMLText }
# ======================= Tables =======================================

# Derived from IETF HTML table standard, see [RFC1942]

# The border attribute sets the thickness of the frame around the
# table. The default units are screen pixels.
# 
# The frame attribute specifies which parts of the frame around
# the table should be rendered. The values are not the same as
# CALS to avoid a name clash with the valign attribute.
TFrame =
  "void"
  | "above"
  | "below"
  | "hsides"
  | "lhs"
  | "rhs"
  | "vsides"
  | "box"
  | "border"
# The rules attribute defines which rules to draw between cells:
# 
# If rules is absent then assume:
#		"none" if border is absent or border="0" otherwise "all"
TRules = "none" | "groups" | "rows" | "cols" | "all"
# horizontal placement of table relative to document

# horizontal alignment attributes for cell contents
# 
# char        alignment char, e.g. char=':'
# charoff     offset for alignment char
cellhalign =
  attribute align { "left" | "center" | "right" | "justify" | "char" }?,
  attribute char { Character }?,
  attribute charoff { Length }?
# vertical alignment attributes for cell contents
cellvalign =
  attribute valign { "top" | "middle" | "bottom" | "baseline" }?
table =
  element table {
    table.attlist,
    caption?,
    (col* | colgroup*),
    thead?,
    tfoot?,
    (tbody+ | tr+)
  }
caption = element caption { caption.attlist, Inline }
thead = element thead { thead.attlist, tr+ }
tfoot = element tfoot { tfoot.attlist, tr+ }
tbody = element tbody { tbody.attlist, tr+ }
colgroup = element colgroup { colgroup.attlist, col* }
col = element col { col.attlist, empty }
tr = element tr { tr.attlist, (th | td)+ }
th = element th { th.attlist, Flow }
td = element td { td.attlist, Flow }
table.attlist &=
  attrs,
  attribute summary { XHTMLText }?,
  attribute width { Length }?,
  attribute border { Pixels }?,
  attribute frame { TFrame }?,
  attribute rules { TRules }?,
  attribute cellspacing { Length }?,
  attribute cellpadding { Length }?
caption.attlist &= attrs
# colgroup groups a set of col elements. It allows you to group
# several semantically related columns together.
colgroup.attlist &=
  attrs,
  [ a:defaultValue = "1" ] attribute span { XHTMLNumber }?,
  attribute width { MultiLength }?,
  cellhalign,
  cellvalign
# col elements define the alignment properties for cells in
# one or more columns.
# 
# The width attribute specifies the width of the columns, e.g.
# 
#		width=64        width in screen pixels
#		width=0.5*      relative width of 0.5
# 
# The span attribute causes the attributes of one
# col element to apply to more than one column.
col.attlist &=
  attrs,
  [ a:defaultValue = "1" ] attribute span { XHTMLNumber }?,
  attribute width { MultiLength }?,
  cellhalign,
  cellvalign
# Use thead to duplicate headers when breaking table
# across page boundaries, or for static headers when
# tbody sections are rendered in scrolling panel.
# 
# Use tfoot to duplicate footers when breaking table
# across page boundaries, or for static footers when
# tbody sections are rendered in scrolling panel.
# 
# Use multiple tbody sections when rules are needed
# between groups of table rows.
thead.attlist &= attrs, cellhalign, cellvalign
tfoot.attlist &= attrs, cellhalign, cellvalign
tbody.attlist &= attrs, cellhalign, cellvalign
tr.attlist &= attrs, cellhalign, cellvalign
# Scope is simpler than headers attribute for common tables
Scope = "row" | "col" | "rowgroup" | "colgroup"
# th is for headers, td for data and for cells acting as both
th.attlist &=
  attrs,
  attribute abbr { XHTMLText }?,
  attribute axis { text }?,
  attribute headers { xsd:IDREFS }?,
  attribute scope { Scope }?,
  [ a:defaultValue = "1" ] attribute rowspan { XHTMLNumber }?,
  [ a:defaultValue = "1" ] attribute colspan { XHTMLNumber }?,
  cellhalign,
  cellvalign
td.attlist &=
  attrs,
  attribute abbr { XHTMLText }?,
  attribute axis { text }?,
  attribute headers { xsd:IDREFS }?,
  attribute scope { Scope }?,
  [ a:defaultValue = "1" ] attribute rowspan { XHTMLNumber }?,
  [ a:defaultValue = "1" ] attribute colspan { XHTMLNumber }?,
  cellhalign,
  cellvalign
# =================== Ruby Elements ====================================

# simple or complex ruby, XHTML 1.1 only
ruby =
  element ruby {
    ruby.attlist,
    # ((rb, (rt | (rp, rt, rp))) | (rbc, rtc, rtc?))
    ((rb,
      (rt | (rp, rt, rp)))
     | (rbc, rtc, rtc?))
  }
ruby.attlist &= attrs
rbc =
  element rbc {
    rbc.attlist,
    # rb+
    rb+
  }
rbc.attlist &= attrs
rtc =
  element rtc {
    rtc.attlist,
    # rt+
    rt+
  }
rtc.attlist &= attrs
rb =
  element rb {
    rb.attlist,
    # inline content excluding <ruby>
    ruby.content
  }
rb.attlist &= attrs
rp =
  element rp {
    rp.attlist,
    # text content, no markup
    text
  }
rp.attlist &= attrs
rt =
  element rt {
    rt.attlist,
    # inline content excluding <ruby>
    ruby.content
  }
rt.attlist &=
  attrs,
  attribute rbspan { xsd:int }?
